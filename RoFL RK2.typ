#import "@preview/diagraph:0.3.6" as diagraph

#set text(12pt, font: "New Computer Modern")

#let title(title, description, author) = [
  #set page(numbering: none)
  #align(center)[
    #v(15em)

    #text(weight: "bold", size: 25pt)[#title]

    #v(0.5cm)

    #text(size: 18pt)[#description]

    #v(1.5cm)

    #text(size: 14pt)[#author]
  ]
]

#title(
  [
    Теория формальных языков\
    Рубежный контроль №2
  ],
  "Вариант №22",
  "Никитин Сергей ИУ9-51Б"
)

#set page(numbering: "1")
// #set heading(numbering: "1.")
#counter(page).update(1)

== Задание 1
Язык SRS $a -> a b, a^2 -> b a^2$ над множеством базисных слов $a^n b a^n$

=== Решение

Для доказательства контекстной свободы построим недетерминированный PDA:

#context diagraph.render(
  read("task1.dot"),
  width: page.width * 0.75,
  math-mode: "math"
)

Теперь проверим язык на регулярность. Рассмотрим регулярный язык $a^* b a^*$. Пересечение нашего языка с этим состоит из слов, имеющих ровно одну b. В нашем языке такие слова можно получить только если вообще не применять правил, т.к. каждое правило увеличивает количество букв b. Из этого следует, что пересечением этих 2-х языков является ${a^n b a^n | n >= 0}$, однако данный язык не является регулярным. Следовательно и исходный язык из условия задачи также не является регулярным.

== Задание 2

Язык ${omega_1 a a omega_2 | omega_1 = omega_3 b omega_4 " " \& " " omega_2 = omega_5 b omega_6 " " \& " " abs(omega_1) = abs(omega_2)}$. Алфавит ${a, b}$.

=== Решение

Предположим, что наш язык является DCFL. Воспользуемся замкнутостью DCFL относительно операции пересечения с регулярным языком. Рассмотрим регулярный язык $a^* b a^* a a a^* b a^*$. Его пересечение с нашим языком будет иметь вид ${a^n b a^m a a a^l b a^k | m + n = l + k}$. По предположению, пересечение должно быть DCFL. Проверим так ли это. В таком случае должен существовать DPDA, который распознаёт этот язык. Рассмотрим префикс $u_n = a^n b a^m$. После прочтения этого префикса автомат будет читать первый символ из центральной строки aa, однако первая a в этом блоке может быть, например, всё ещё частью префикса. В этом случае автомат должен:
- в первом случае --- перейти к проверке правой половины слова (начать доставать символы из стека)
- во втором случае --- продолжать накапливать информацию о его длине (класть символы в стек)

Эти действия различны, несмотря на то, что входной символ один и тот же и состояния и вершины стека одинаковы. Следовательно, переход не может быть детерминированным и пересечение исходного языка с регулярным не является DCFL, а это значит, что наше исходное предположение является ложным.

== Задание 3
Язык атрибутной грамматики:

$S -> a S b S$ #h(1em) ; #h(1em) $S_0.a := S_1.a + S_2.a$, $S_1.a == S_2.a$

$S -> T$ #h(2.65em) ; #h(1em) $S.a := T.a$

$T -> a T$ #h(2.1em) ; #h(1em) $T_0.a := T_1.a + 1$

$T -> b T$ #h(2.25em) ; #h(1em) $T_0.a := [T_1.a\/2]$

$T -> c$ #h(3em) ; #h(1em) $T.a := 0$

=== Решение

Все атрибуты в грамматике являются синтезируемыми, но в первом правиле есть условие $S_1.a == S_2.a$, которое не вычисляет значение, а проверяет его. Данное условие вводит контекстную зависимость, так как требует равенства атрибутов двух разных поддеревьев. Это условие не может быть выражено в рамках контекстно-свободной грамматики по нескольким причинам:
- Атрибут $.a$ вычисляется как целое число на основе строки, порожденной из $T$ или $S$.
- Вычисление атрибута зависит от всей подстроки и его значение может быть сколь угодно большим.
- Проверка равенства двух таких атрибутов требует сравнения результатов двух независимых вычислений, что эквивалентно проверке глобального свойства.

Рассмотрим подмножество языка, порождаемого грамматикой:
$
L^' = {a omega_1 c b omega_2 c | f(omega_1) = f(omega_2)},
$
где $f(omega)$ --- значение атрибута, вычисляемое для строки $w$ по правилам для $T$. Если бы $L^'$ был контекстно-свободным, то и пересечение с регулярным языком, например, с $a^* c b^* c$, тоже давало бы КС язык. Проблема здесь в том, что условие $f(omega_1) = f(omega_2)$ требует равенства двух чисел, представленных в виде последовательностей операций +1 и /2. Более того, функция $f(w)$ может принимать произвольные натуральные значения, и проверка её равенства для двух подстрок потребует неограниченной памяти.

Таким образом данный язык атрибутной грамматики не является КС, хотя, если бы условие отсутствовало, то грамматика была бы чисто синтезируемой (S-атрибутной) и порождала бы КС язык.


