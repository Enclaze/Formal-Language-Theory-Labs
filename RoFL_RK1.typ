#import "@preview/diagraph:0.3.6" as diagraph

#set text(12pt, font: "New Computer Modern")

#let title(title, description, author) = [
  #set page(numbering: none)
  #align(center)[
    #v(15em)

    #text(weight: "bold", size: 25pt)[#title]

    #v(0.5cm)

    #text(size: 18pt)[#description]

    #v(1.5cm)

    #text(size: 14pt)[#author]
  ]
]

#title(
  [
    Теория формальных языков\
    Рубежный контроль №1
  ],
  "Вариант №22",
  "Никитин Сергей ИУ9-51Б"
)

#set page(numbering: "1")
// #set heading(numbering: "1.")
#counter(page).update(1)

== Задание 1
Язык контекстно-свободных грамматик, порождающих языки - подмножества $("ab")^*$. Слова языка могут включать нетерминалы S (где S - стартовый), A, символ $->$, терминалы a, b и разделитель ;.

=== Решение

// Левая часть --- нетерминал
// S -> ab S | A
// A -> ab | A ab A

// S -> aA; A -> bS; A -> b;

// Obs:
// у S всегда первая буква a, последняя b (очев);
// в обоих правилах не может быть подстрок вида aa, bb, aS, Sb (см. неприятный случай);
// все пары ab можно сразу убирать (схлопывать);
// если S -> ..., то он не должен заканчиваться на a и начинаться на b;
// на деле основная задача -- ограничить правило на A (т.е., на какую букву начинается, на какую заканчивается) и проверить, что это требование выполняется

// Неприятный случай:
// A -> содержит запрещённые подслова, но в
// S -> нет буквы A, а значит должно подходить

// Тупое построение:
// Начальные состояния циклов --- (первая буква A, последняя буква A, есть ли буквы A в S)
// Начальное состояние НКА? --- (0, 0, 0)
/*
Есть идея написать 4 разные регулярки и объединить их через |

Регулярки:

$1. (S->(a b)^* ;)^+ (S->(S^* (a b)^* S^*) ;)^+ \

#line(length: 11cm)\

2. (S->(S^* (a b)^* S^* A^+ S^* (a b)^* S^*)^+ ;)^+ (A-> ((a b)^* S^*)^* ;)^+  \ (A->(S^* (a b)^* S^* A^* S^* (a b)^*)^+ ;)^+ (S->((a b)^* A^+ (a b)^*)^* ;)^+ \

#line(length: 11cm)\

3.(S->(S^* (a b)^* S^* (a A)^+ S^* (a b)^+ S^*)^* ;)^+ (A->(b S^* (a A)^* S^+ (a b)^* S^*)^* ;)^+ \ (A-> b S^* (a b)^* S^* ;)^+ (S->((a b)^* (a A)^* (a b)^* ;)^+) \

#line(length: 11cm)\

4. (S-> (S^* (a b)^* (S^* a A b S^*)^* (a b)^* S^*)^* ;)^* (S->(a b)^* (a A b)^* (a b)^*)^* \ (A->b(S^* (a b)^* (a A b)^*)^* a;)^* (A->b(S^* (a b)^*)^* a;)^+$
*/

#pagebreak()
 
== Задание 2

Язык ${a^*omega b^*| |omega|_("abab") = |omega|_("ba") "& " omega in {a, b}^+}$

=== Решение

#context diagraph.render(
  read("task2.dot"),
  width: page.width * 0.75,
  math-mode: "math"
)

== Задание 3
Язык слов, в котором число подстрок aba и число подстрок bab не совпадают. Алфавит {a, b, c}.

=== Решение

Докажем, что язык $L$ не является регулярным. Рассмотрим язык $overline(L) = {omega | |omega|_(a b a) = |omega|_(b a b) "& " omega in {a, b, c}^*}$. Если $overline(L)$ является регулярным, то $L$ также должен быть регулярным.

Построим таблицу конкатенаций для языка $overline(L)$:

#align(center)[
#table(
  columns: 7,
  align: center,
  [], [$a$], [$a a b a$], [$a a b a a b a$], [$dots$], [$a (a b a)^k$], [$a (a b a)^(k+1)$],
  [$b a b$], [$+$], [$-$], [$-$], [$dots$], [$-$], [$-$],
  [$b a b b a b$], [$-$], [$+$], [$-$], [$dots$], [$-$], [$-$],
  [$dots$], [$dots$], [$dots$], [$dots$], [$dots$], [$dots$], [$dots$],
  [$(b a b)^(k+1)$], [$-$], [$-$], [$-$], [$dots$], [$+$], [$-$]
)
]

Видим, что все префиксы различимы, значит $overline(L)$ не регулярен, следовательно, $L$ также не регулярен.

Построим для $L$ следующий PDA:

#context diagraph.render(
  read("task3.dot"),
  width: page.width * 0.75,
  math-mode: "math"
)


